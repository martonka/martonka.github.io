<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kudu C++ client API: kudu::client::KuduScanner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>kudu</b>::<b>client</b>::<a class="el" href="classkudu_1_1client_1_1KuduScanner.html">KuduScanner</a>
  </div>
</div>
<div class="contents">
<h1>kudu::client::KuduScanner Class Reference</h1><!-- doxytag: class="kudu::client::KuduScanner" -->
<p>This class is a representation of a single scan.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="client_8h_source.html">client.h</a>&gt;</code></p>

<p><a href="classkudu_1_1client_1_1KuduScanner-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a36fdb59d6488618363331269d3f58348">ReadMode</a> { <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a36fdb59d6488618363331269d3f58348a8694cef688d819806fa9a85b002231a8">READ_LATEST</a>, 
<a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a36fdb59d6488618363331269d3f58348a380798cc81589d865b7b2549e186b2e2">READ_AT_SNAPSHOT</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The read modes for scanners. </p>
 <a href="classkudu_1_1client_1_1KuduScanner.html#a36fdb59d6488618363331269d3f58348">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a3d6c79325c9da9741d0accf1b43bf7f9">OrderMode</a> { <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a3d6c79325c9da9741d0accf1b43bf7f9adfeea547de613f36a0aff9f585671ec3">UNORDERED</a>, 
<a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a3d6c79325c9da9741d0accf1b43bf7f9a4395ad2ec57ce53e30d8b5748fa2c63a">ORDERED</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kScanTimeoutMillis</b> =  30000
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a2c621f778072a02f4092e96a0baf8180">KuduScanner</a> (<a class="el" href="classkudu_1_1client_1_1KuduTable.html">KuduTable</a> *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#abb10b26056757bf81c410d3d5e6bcc01">SetProjectedColumnNames</a> (const std::vector&lt; std::string &gt; &amp;col_names) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a8d938c6efc1b36d456c91b5af0b1578d">SetProjectedColumnIndexes</a> (const std::vector&lt; int &gt; &amp;col_indexes) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a5eff07067d76a60ab12e2d555e3db1ce">SetProjectedColumns</a> (const std::vector&lt; std::string &gt; &amp;col_names) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a47b0fcd30f8002cb4fdcf69351896b74">AddConjunctPredicate</a> (<a class="el" href="classkudu_1_1client_1_1KuduPredicate.html">KuduPredicate</a> *pred) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a67691944fc112f43c565ab4486514b86">AddLowerBound</a> (const <a class="el" href="classkudu_1_1KuduPartialRow.html">KuduPartialRow</a> &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#aff1fbf928d29bceff805d7d8b9904282">AddLowerBoundRaw</a> (const <a class="el" href="classkudu_1_1Slice.html">Slice</a> &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a551fd38d48a686f2662727a82e79bd3d">AddExclusiveUpperBound</a> (const <a class="el" href="classkudu_1_1KuduPartialRow.html">KuduPartialRow</a> &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#aaa45befeacfea4d7722c9f7c661fa83a">AddExclusiveUpperBoundRaw</a> (const <a class="el" href="classkudu_1_1Slice.html">Slice</a> &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#ab53b88307028a50f66bcffe5e78c6d6e">AddLowerBoundPartitionKeyRaw</a> (const <a class="el" href="classkudu_1_1Slice.html">Slice</a> &amp;partition_key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#aa951a6ec3aeb82c82afe35d8e3ba18a9">AddExclusiveUpperBoundPartitionKeyRaw</a> (const <a class="el" href="classkudu_1_1Slice.html">Slice</a> &amp;partition_key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a4a4a2e354b3113561758b9bf4095d310">SetCacheBlocks</a> (bool cache_blocks)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#aa1ff3c11d9ac9f8183189ea5ac1ed9f1">Open</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#aa4a0caf7142880255d7aac1d75f33d21">KeepAlive</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#ac673dd15cb038e75787af7e74087e874">Close</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#ab04c2012970498590d2d2034d6a44d34">HasMoreRows</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a409a42496942e93df5f4879b7a348e87">NextBatch</a> (std::vector&lt; KuduRowResult &gt; *rows)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#af1475d9a0667839c1ed9c3714b47d487">NextBatch</a> (<a class="el" href="classkudu_1_1client_1_1KuduScanBatch.html">KuduScanBatch</a> *batch)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#ac2bce7bd17627a3aa46f7d7fdb4c0c10">GetCurrentServer</a> (<a class="el" href="classkudu_1_1client_1_1KuduTabletServer.html">KuduTabletServer</a> **server)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classkudu_1_1client_1_1ResourceMetrics.html">ResourceMetrics</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a640d0d9de62587b29afbec22b7c6b628">GetResourceMetrics</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#af82c4ccb442c222033841dd65cf5a67c">SetBatchSizeBytes</a> (uint32_t batch_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#af1db3f372fe3d0f30cd0b6a36b783cc8">SetSelection</a> (<a class="el" href="classkudu_1_1client_1_1KuduClient.html#aef70c7f3a596ecda4040f9d46514b11a">KuduClient::ReplicaSelection</a> selection) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a248e0a05e7bfdc31b5b8d363a937e81e">SetReadMode</a> (<a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a36fdb59d6488618363331269d3f58348">ReadMode</a> read_mode) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a915b45a3edca37971235070c057a3e82">SetOrderMode</a> (<a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a3d6c79325c9da9741d0accf1b43bf7f9">OrderMode</a> order_mode) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a107a8a682c0977272e0ae47746d39e6f">SetFaultTolerant</a> () WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a5b36a405daf09399438d5501b25b9f9f">SetSnapshotMicros</a> (uint64_t snapshot_timestamp_micros) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#ab13dbb301197b411dec4cd6870801bae">SetSnapshotRaw</a> (uint64_t snapshot_timestamp) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a97c9f5e6a1056484c88ced411e19bee6">SetTimeoutMillis</a> (int millis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1client_1_1KuduSchema.html">KuduSchema</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a7fad1430b8e1d4caf0614f690fa2666f">GetProjectionSchema</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#aea36ffb783be3ffdf370cd7399f232d3">ToString</a> () const </td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08335df27491aef74f8ed104799ab541"></a><!-- doxytag: member="kudu::client::KuduScanner::KuduScanToken" ref="a08335df27491aef74f8ed104799ab541" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>KuduScanToken</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class is a representation of a single scan. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This class is not thread-safe, though different scanners on different threads may share a single <a class="el" href="classkudu_1_1client_1_1KuduTable.html" title="A representation of a table on a particular cluster.">KuduTable</a> object. </dd></dl>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a60615ffe5fe82c5dcd12fec47502bec1"></a><!-- doxytag: member="kudu::client::KuduScanner::@0" ref="a60615ffe5fe82c5dcd12fec47502bec1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default scanner timeout. This is set to 3x the default RPC timeout returned by <a class="el" href="classkudu_1_1client_1_1KuduClientBuilder.html#a1813e8c8d24e92a0a710724000e2b3df">KuduClientBuilder::default_rpc_timeout()</a>. </p>

</div>
</div>
<a class="anchor" id="a3d6c79325c9da9741d0accf1b43bf7f9"></a><!-- doxytag: member="kudu::client::KuduScanner::OrderMode" ref="a3d6c79325c9da9741d0accf1b43bf7f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a3d6c79325c9da9741d0accf1b43bf7f9">kudu::client::KuduScanner::OrderMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Whether the rows should be returned in order.</p>
<p>This affects the fault-tolerance properties of a scanner. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3d6c79325c9da9741d0accf1b43bf7f9adfeea547de613f36a0aff9f585671ec3"></a><!-- doxytag: member="UNORDERED" ref="a3d6c79325c9da9741d0accf1b43bf7f9adfeea547de613f36a0aff9f585671ec3" args="" -->UNORDERED</em>&nbsp;</td><td>
<p>Rows will be returned in an arbitrary order determined by the tablet server. This is efficient, but unordered scans are not fault-tolerant and cannot be resumed in the case of tablet server failure.</p>
<p>This is the default mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3d6c79325c9da9741d0accf1b43bf7f9a4395ad2ec57ce53e30d8b5748fa2c63a"></a><!-- doxytag: member="ORDERED" ref="a3d6c79325c9da9741d0accf1b43bf7f9a4395ad2ec57ce53e30d8b5748fa2c63a" args="" -->ORDERED</em>&nbsp;</td><td>
<p>Rows will be returned ordered by primary key. Sorting the rows imposes additional overhead on the tablet server, but means that scans are fault-tolerant and will be resumed at another tablet server in the case of a failure. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a36fdb59d6488618363331269d3f58348"></a><!-- doxytag: member="kudu::client::KuduScanner::ReadMode" ref="a36fdb59d6488618363331269d3f58348" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a36fdb59d6488618363331269d3f58348">kudu::client::KuduScanner::ReadMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The read modes for scanners. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a36fdb59d6488618363331269d3f58348a8694cef688d819806fa9a85b002231a8"></a><!-- doxytag: member="READ_LATEST" ref="a36fdb59d6488618363331269d3f58348a8694cef688d819806fa9a85b002231a8" args="" -->READ_LATEST</em>&nbsp;</td><td>
<p>When <code>READ_LATEST</code> is specified the server will always return committed writes at the time the request was received. This type of read does not return a snapshot timestamp and is not repeatable.</p>
<p>In ACID terms this corresponds to Isolation mode: "Read Committed"</p>
<p>This is the default mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a36fdb59d6488618363331269d3f58348a380798cc81589d865b7b2549e186b2e2"></a><!-- doxytag: member="READ_AT_SNAPSHOT" ref="a36fdb59d6488618363331269d3f58348a380798cc81589d865b7b2549e186b2e2" args="" -->READ_AT_SNAPSHOT</em>&nbsp;</td><td>
<p>When <code>READ_AT_SNAPSHOT</code> is specified the server will attempt to perform a read at the provided timestamp. If no timestamp is provided the server will take the current time as the snapshot timestamp. In this mode reads are repeatable, i.e. all future reads at the same timestamp will yield the same data. This is performed at the expense of waiting for in-flight transactions whose timestamp is lower than the snapshot's timestamp to complete, so it might incur a latency penalty. See <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a5b36a405daf09399438d5501b25b9f9f">KuduScanner::SetSnapshotMicros()</a> and <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#ab13dbb301197b411dec4cd6870801bae">KuduScanner::SetSnapshotRaw()</a> for details.</p>
<p>In ACID terms this, by itself, corresponds to Isolation mode "Repeatable
        Read". If all writes to the scanned tablet are made externally consistent, then this corresponds to Isolation mode "Strict-Serializable".</p>
<dl class="note"><dt><b>Note:</b></dt><dd>There are currently "holes", which happen in rare edge conditions, by which writes are sometimes not externally consistent even when action was taken to make them so. In these cases Isolation may degenerate to mode "Read Committed". See KUDU-430. </dd></dl>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2c621f778072a02f4092e96a0baf8180"></a><!-- doxytag: member="kudu::client::KuduScanner::KuduScanner" ref="a2c621f778072a02f4092e96a0baf8180" args="(KuduTable *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kudu::client::KuduScanner::KuduScanner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduTable.html">KuduTable</a> *&nbsp;</td>
          <td class="paramname"> <em>table</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor for <a class="el" href="classkudu_1_1client_1_1KuduScanner.html" title="This class is a representation of a single scan.">KuduScanner</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>table</em>&nbsp;</td><td>The table to perfrom scan. The given object must remain valid for the lifetime of this scanner object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a47b0fcd30f8002cb4fdcf69351896b74"></a><!-- doxytag: member="kudu::client::KuduScanner::AddConjunctPredicate" ref="a47b0fcd30f8002cb4fdcf69351896b74" args="(KuduPredicate *pred) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::AddConjunctPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduPredicate.html">KuduPredicate</a> *&nbsp;</td>
          <td class="paramname"> <em>pred</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a predicate for the scan.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pred</em>&nbsp;</td><td>Predicate to set. The <a class="el" href="classkudu_1_1client_1_1KuduScanTokenBuilder.html" title="Builds scan tokens for a table.">KuduScanTokenBuilder</a> instance takes ownership of the parameter even if a bad <a class="el" href="classkudu_1_1Status.html" title="A representation of an operation&#39;s outcome.">Status</a> is returned. Multiple calls of this method make the specified set of predicates work in conjunction, i.e. all predicates must be true for a row to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a551fd38d48a686f2662727a82e79bd3d"></a><!-- doxytag: member="kudu::client::KuduScanner::AddExclusiveUpperBound" ref="a551fd38d48a686f2662727a82e79bd3d" args="(const KuduPartialRow &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::AddExclusiveUpperBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkudu_1_1KuduPartialRow.html">KuduPartialRow</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add an upper bound (exclusive) primary key for the scan.</p>
<p>If any bound is already added, this bound is intersected with that one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>The key to setup the upper bound. The scanner makes a copy of the parameter, the caller may free it afterward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="aa951a6ec3aeb82c82afe35d8e3ba18a9"></a><!-- doxytag: member="kudu::client::KuduScanner::AddExclusiveUpperBoundPartitionKeyRaw" ref="aa951a6ec3aeb82c82afe35d8e3ba18a9" args="(const Slice &amp;partition_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::AddExclusiveUpperBoundPartitionKeyRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkudu_1_1Slice.html">Slice</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>partition_key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add an upper bound (exclusive) partition key for the scan.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is unstable, and for internal use only.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>partition_key</em>&nbsp;</td><td>The scanner makes a copy of the parameter, the caller may invalidate it afterward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa45befeacfea4d7722c9f7c661fa83a"></a><!-- doxytag: member="kudu::client::KuduScanner::AddExclusiveUpperBoundRaw" ref="aaa45befeacfea4d7722c9f7c661fa83a" args="(const Slice &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::AddExclusiveUpperBoundRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkudu_1_1Slice.html">Slice</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add an upper bound (exclusive) primary key for the scan.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Use <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a551fd38d48a686f2662727a82e79bd3d">AddExclusiveUpperBound()</a> instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>The encoded primary key is an opaque slice of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a67691944fc112f43c565ab4486514b86"></a><!-- doxytag: member="kudu::client::KuduScanner::AddLowerBound" ref="a67691944fc112f43c565ab4486514b86" args="(const KuduPartialRow &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::AddLowerBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkudu_1_1KuduPartialRow.html">KuduPartialRow</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a lower bound (inclusive) primary key for the scan.</p>
<p>If any bound is already added, this bound is intersected with that one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>Lower bound primary key to add. The <a class="el" href="classkudu_1_1client_1_1KuduScanTokenBuilder.html" title="Builds scan tokens for a table.">KuduScanTokenBuilder</a> instance does not take ownership of the parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="ab53b88307028a50f66bcffe5e78c6d6e"></a><!-- doxytag: member="kudu::client::KuduScanner::AddLowerBoundPartitionKeyRaw" ref="ab53b88307028a50f66bcffe5e78c6d6e" args="(const Slice &amp;partition_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::AddLowerBoundPartitionKeyRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkudu_1_1Slice.html">Slice</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>partition_key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a lower bound (inclusive) partition key for the scan.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is unstable, and for internal use only.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>partition_key</em>&nbsp;</td><td>The scanner makes a copy of the parameter: the caller may invalidate it afterward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="aff1fbf928d29bceff805d7d8b9904282"></a><!-- doxytag: member="kudu::client::KuduScanner::AddLowerBoundRaw" ref="aff1fbf928d29bceff805d7d8b9904282" args="(const Slice &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::AddLowerBoundRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkudu_1_1Slice.html">Slice</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add lower bound for the scan.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a67691944fc112f43c565ab4486514b86">AddLowerBound()</a> instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>The primary key to use as an opaque slice of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="ac673dd15cb038e75787af7e74087e874"></a><!-- doxytag: member="kudu::client::KuduScanner::Close" ref="ac673dd15cb038e75787af7e74087e874" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kudu::client::KuduScanner::Close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the scanner.</p>
<p>Closing the scanner releases resources on the server. This call does not block, and will not ever fail, even if the server cannot be contacted.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The scanner is reset to its initial state by this function. You'll have to re-add any projection, predicates, etc if you want to reuse this object. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2bce7bd17627a3aa46f7d7fdb4c0c10"></a><!-- doxytag: member="kudu::client::KuduScanner::GetCurrentServer" ref="ac2bce7bd17627a3aa46f7d7fdb4c0c10" args="(KuduTabletServer **server)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::GetCurrentServer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduTabletServer.html">KuduTabletServer</a> **&nbsp;</td>
          <td class="paramname"> <em>server</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the <a class="el" href="classkudu_1_1client_1_1KuduTabletServer.html" title="In-memory representation of a remote tablet server.">KuduTabletServer</a> that is currently handling the scan.</p>
<p>More concretely, this is the server that handled the most recent <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#aa1ff3c11d9ac9f8183189ea5ac1ed9f1">Open()</a> or <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a409a42496942e93df5f4879b7a348e87">NextBatch()</a> RPC made by the server.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>server</em>&nbsp;</td><td>Placeholder for the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fad1430b8e1d4caf0614f690fa2666f"></a><!-- doxytag: member="kudu::client::KuduScanner::GetProjectionSchema" ref="a7fad1430b8e1d4caf0614f690fa2666f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1client_1_1KuduSchema.html">KuduSchema</a> kudu::client::KuduScanner::GetProjectionSchema </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Schema of the projection being scanned. </dd></dl>

</div>
</div>
<a class="anchor" id="a640d0d9de62587b29afbec22b7c6b628"></a><!-- doxytag: member="kudu::client::KuduScanner::GetResourceMetrics" ref="a640d0d9de62587b29afbec22b7c6b628" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classkudu_1_1client_1_1ResourceMetrics.html">ResourceMetrics</a>&amp; kudu::client::KuduScanner::GetResourceMetrics </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Cumulative resource metrics since the scan was started. </dd></dl>

</div>
</div>
<a class="anchor" id="ab04c2012970498590d2d2034d6a44d34"></a><!-- doxytag: member="kudu::client::KuduScanner::HasMoreRows" ref="ab04c2012970498590d2d2034d6a44d34" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kudu::client::KuduScanner::HasMoreRows </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if there may be rows to be fetched from this scanner.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if there may be rows to be fetched from this scanner. The method returns <code>true</code> provided there's at least one more tablet left to scan, even if that tablet has no data (we'll only know once we scan it). It will also be <code>true</code> after the initially opening the scanner before NextBatch is called for the first time. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4a0caf7142880255d7aac1d75f33d21"></a><!-- doxytag: member="kudu::client::KuduScanner::KeepAlive" ref="aa4a0caf7142880255d7aac1d75f33d21" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::KeepAlive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Keep the current remote scanner alive.</p>
<p>Keep the current remote scanner alive on the Tablet server for an additional time-to-live (set by a configuration flag on the tablet server). This is useful if the interval in between <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a409a42496942e93df5f4879b7a348e87">NextBatch()</a> calls is big enough that the remote scanner might be garbage collected (default ttl is set to 60 secs.). This does not invalidate any previously fetched results.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. In particular, this method returns a non-OK status if the scanner was already garbage collected or if the TabletServer was unreachable, for any reason. Note that a non-OK status returned by this method should not be taken as indication that the scan has failed. Subsequent calls to <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a409a42496942e93df5f4879b7a348e87">NextBatch()</a> might still be successful, particularly if <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a107a8a682c0977272e0ae47746d39e6f">SetFaultTolerant()</a> has been called. </dd></dl>

</div>
</div>
<a class="anchor" id="af1475d9a0667839c1ed9c3714b47d487"></a><!-- doxytag: member="kudu::client::KuduScanner::NextBatch" ref="af1475d9a0667839c1ed9c3714b47d487" args="(KuduScanBatch *batch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::NextBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduScanBatch.html">KuduScanBatch</a> *&nbsp;</td>
          <td class="paramname"> <em>batch</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch the next batch of results for this scanner.</p>
<p>A single <a class="el" href="classkudu_1_1client_1_1KuduScanBatch.html" title="A batch of zero or more rows returned by a scan operation.">KuduScanBatch</a> object may be reused. Each subsequent call replaces the data from the previous call, and invalidates any <a class="el" href="classkudu_1_1client_1_1KuduScanBatch.html#a92bbfa48e9b503181c2dfb5f11f14e4e">KuduScanBatch::RowPtr</a> objects previously obtained from the batch. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>batch</em>&nbsp;</td><td>Placeholder for the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a409a42496942e93df5f4879b7a348e87"></a><!-- doxytag: member="kudu::client::KuduScanner::NextBatch" ref="a409a42496942e93df5f4879b7a348e87" args="(std::vector&lt; KuduRowResult &gt; *rows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::NextBatch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; KuduRowResult &gt; *&nbsp;</td>
          <td class="paramname"> <em>rows</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get next batch of rows.</p>
<p>Clears 'rows' and populates it with the next batch of rows from the tablet server. A call to <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a409a42496942e93df5f4879b7a348e87">NextBatch()</a> invalidates all previously fetched results which might now be pointing to garbage memory.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#af1475d9a0667839c1ed9c3714b47d487">NextBatch(KuduScanBatch*)</a> instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>rows</em>&nbsp;</td><td>Placeholder for the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1ff3c11d9ac9f8183189ea5ac1ed9f1"></a><!-- doxytag: member="kudu::client::KuduScanner::Open" ref="aa1ff3c11d9ac9f8183189ea5ac1ed9f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::Open </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Result status of the operation (begin scanning). </dd></dl>

</div>
</div>
<a class="anchor" id="af82c4ccb442c222033841dd65cf5a67c"></a><!-- doxytag: member="kudu::client::KuduScanner::SetBatchSizeBytes" ref="af82c4ccb442c222033841dd65cf5a67c" args="(uint32_t batch_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetBatchSizeBytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>batch_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the hint for the size of the next batch in bytes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>batch_size</em>&nbsp;</td><td>The hint of batch size to set. If setting to 0 before calling <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#aa1ff3c11d9ac9f8183189ea5ac1ed9f1">Open()</a>, it means that the first call to the tablet server won't return data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a4a2e354b3113561758b9bf4095d310"></a><!-- doxytag: member="kudu::client::KuduScanner::SetCacheBlocks" ref="a4a4a2e354b3113561758b9bf4095d310" args="(bool cache_blocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetCacheBlocks </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>cache_blocks</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the block caching policy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache_blocks</em>&nbsp;</td><td>If <code>true</code>, scanned data blocks will be cached in memory and made available for future scans. Default is <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a107a8a682c0977272e0ae47746d39e6f"></a><!-- doxytag: member="kudu::client::KuduScanner::SetFaultTolerant" ref="a107a8a682c0977272e0ae47746d39e6f" args="() WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetFaultTolerant </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make scans resumable at another tablet server if current server fails.</p>
<p>Scans are by default non fault-tolerant, and scans will fail if scanning an individual tablet fails (for example, if a tablet server crashes in the middle of a tablet scan). If this method is called, scans will be resumed at another tablet server in the case of failure.</p>
<p>Fault-tolerant scans typically have lower throughput than non fault-tolerant scans. Fault tolerant scans use <code>READ_AT_SNAPSHOT</code> mode: if no snapshot timestamp is provided, the server will pick one.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a915b45a3edca37971235070c057a3e82"></a><!-- doxytag: member="kudu::client::KuduScanner::SetOrderMode" ref="a915b45a3edca37971235070c057a3e82" args="(OrderMode order_mode) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetOrderMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a3d6c79325c9da9741d0accf1b43bf7f9">OrderMode</a>&nbsp;</td>
          <td class="paramname"> <em>order_mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Use <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a107a8a682c0977272e0ae47746d39e6f">SetFaultTolerant()</a> instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>order_mode</em>&nbsp;</td><td>Result record orderind mode to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d938c6efc1b36d456c91b5af0b1578d"></a><!-- doxytag: member="kudu::client::KuduScanner::SetProjectedColumnIndexes" ref="a8d938c6efc1b36d456c91b5af0b1578d" args="(const std::vector&lt; int &gt; &amp;col_indexes) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetProjectedColumnIndexes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>col_indexes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the column projection by passing the column indexes to read.</p>
<p>Set the column projection used for this scanner by passing the column indices to read. A call to this method overrides any previous call to <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#abb10b26056757bf81c410d3d5e6bcc01">SetProjectedColumnNames()</a> or <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a8d938c6efc1b36d456c91b5af0b1578d">SetProjectedColumnIndexes()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>col_indexes</em>&nbsp;</td><td>Column indices for the projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="abb10b26056757bf81c410d3d5e6bcc01"></a><!-- doxytag: member="kudu::client::KuduScanner::SetProjectedColumnNames" ref="abb10b26056757bf81c410d3d5e6bcc01" args="(const std::vector&lt; std::string &gt; &amp;col_names) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetProjectedColumnNames </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>col_names</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the projection for the scanner using column names.</p>
<p>Set the projection used for the scanner by passing column names to read. This overrides any previous call to <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#abb10b26056757bf81c410d3d5e6bcc01">SetProjectedColumnNames()</a> or <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a8d938c6efc1b36d456c91b5af0b1578d">SetProjectedColumnIndexes()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>col_names</em>&nbsp;</td><td>Column names to use for the projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a5eff07067d76a60ab12e2d555e3db1ce"></a><!-- doxytag: member="kudu::client::KuduScanner::SetProjectedColumns" ref="a5eff07067d76a60ab12e2d555e3db1ce" args="(const std::vector&lt; std::string &gt; &amp;col_names) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetProjectedColumns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>col_names</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#abb10b26056757bf81c410d3d5e6bcc01">SetProjectedColumnNames()</a> instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>col_names</em>&nbsp;</td><td>Column names to use for the projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a248e0a05e7bfdc31b5b8d363a937e81e"></a><!-- doxytag: member="kudu::client::KuduScanner::SetReadMode" ref="a248e0a05e7bfdc31b5b8d363a937e81e" args="(ReadMode read_mode) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetReadMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a36fdb59d6488618363331269d3f58348">ReadMode</a>&nbsp;</td>
          <td class="paramname"> <em>read_mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the ReadMode. Default is <code>READ_LATEST</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>read_mode</em>&nbsp;</td><td>Read mode to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="af1db3f372fe3d0f30cd0b6a36b783cc8"></a><!-- doxytag: member="kudu::client::KuduScanner::SetSelection" ref="af1db3f372fe3d0f30cd0b6a36b783cc8" args="(KuduClient::ReplicaSelection selection) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetSelection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduClient.html#aef70c7f3a596ecda4040f9d46514b11a">KuduClient::ReplicaSelection</a>&nbsp;</td>
          <td class="paramname"> <em>selection</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the replica selection policy while scanning.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>selection</em>&nbsp;</td><td>The policy to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Kill this method in favor of a consistency-level-based API. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b36a405daf09399438d5501b25b9f9f"></a><!-- doxytag: member="kudu::client::KuduScanner::SetSnapshotMicros" ref="a5b36a405daf09399438d5501b25b9f9f" args="(uint64_t snapshot_timestamp_micros) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetSnapshotMicros </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>snapshot_timestamp_micros</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set snapshot timestamp for scans in <code>READ_AT_SNAPSHOT</code> mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>snapshot_timestamp_micros</em>&nbsp;</td><td>Timestamp to set in in microseconds since the Epoch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="ab13dbb301197b411dec4cd6870801bae"></a><!-- doxytag: member="kudu::client::KuduScanner::SetSnapshotRaw" ref="ab13dbb301197b411dec4cd6870801bae" args="(uint64_t snapshot_timestamp) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetSnapshotRaw </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>snapshot_timestamp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set snapshot timestamp for scans in <code>READ_AT_SNAPSHOT</code> mode (raw).</p>
<p>See <a class="el" href="classkudu_1_1client_1_1KuduClient.html#a3a671b3540c74ef7c358bb98e95031e0">KuduClient::GetLatestObservedTimestamp()</a> for details on how to use this method to achieve Read-Your-Writes behavior.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is experimental and will either disappear or change in a future release.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>snapshot_timestamp</em>&nbsp;</td><td>Timestamp to set in raw encoded form (i.e. as returned by a previous call to a server). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a97c9f5e6a1056484c88ced411e19bee6"></a><!-- doxytag: member="kudu::client::KuduScanner::SetTimeoutMillis" ref="a97c9f5e6a1056484c88ced411e19bee6" args="(int millis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduScanner::SetTimeoutMillis </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>millis</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the maximum time that <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#aa1ff3c11d9ac9f8183189ea5ac1ed9f1">Open()</a> and <a class="el" href="classkudu_1_1client_1_1KuduScanner.html#a409a42496942e93df5f4879b7a348e87">NextBatch()</a> are allowed to take.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td>Timeout to set (in milliseconds). Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="aea36ffb783be3ffdf370cd7399f232d3"></a><!-- doxytag: member="kudu::client::KuduScanner::ToString" ref="aea36ffb783be3ffdf370cd7399f232d3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string kudu::client::KuduScanner::ToString </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>String representation of this scan. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/kudu/client/<a class="el" href="client_8h_source.html">client.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
  <small>Generated for Kudu version 1.0.1 on Tue Oct 11 08:52:01 2016 by Doxygen 1.6.1</small>
  <br>
  <small>Copyright © 2016 The Apache Software Foundation.</small>
</address>
</body>
</html>
