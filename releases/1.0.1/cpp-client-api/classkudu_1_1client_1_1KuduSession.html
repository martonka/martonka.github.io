<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kudu C++ client API: kudu::client::KuduSession Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>kudu</b>::<b>client</b>::<a class="el" href="classkudu_1_1client_1_1KuduSession.html">KuduSession</a>
  </div>
</div>
<div class="contents">
<h1>kudu::client::KuduSession Class Reference</h1><!-- doxytag: class="kudu::client::KuduSession" --><!-- doxytag: inherits="std::tr1::enable_shared_from_this" -->
<p>Representation of a Kudu client session.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="client_8h_source.html">client.h</a>&gt;</code></p>

<p>Inherits std::tr1::enable_shared_from_this&lt; KuduSession &gt;.</p>

<p><a href="classkudu_1_1client_1_1KuduSession-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19">FlushMode</a> { <a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19ad74b76e407e62ca951d369521636df2b">AUTO_FLUSH_SYNC</a>, 
<a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19a520b8eef7ef0fd149b2757faf43972b1">AUTO_FLUSH_BACKGROUND</a>, 
<a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19a1db3efc2094da09aae45bb68475cdb4a">MANUAL_FLUSH</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Modes of flush operations. </p>
 <a href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22">ExternalConsistencyMode</a> { <a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22ae978fab7451faebf4399830b603c855c">CLIENT_PROPAGATED</a>, 
<a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22a70010f3ef1f70b99b02328c024c436c9">COMMIT_WAIT</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The possible external consistency modes on which Kudu operates. </p>
 <a href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a83555781b5a037f87c215e565ecf1a8f">SetFlushMode</a> (<a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19">FlushMode</a> m) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a56d1c7f47dfcaf5121b15a4435a8eeca">SetExternalConsistencyMode</a> (<a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22">ExternalConsistencyMode</a> m) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aefa9bbc51c27104ce103b9ecda3b8abf">SetMutationBufferSpace</a> (size_t size_bytes) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a7311344cec37b3847217197c35467cdf">SetMutationBufferFlushWatermark</a> (double watermark_pct) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabe75f0688f992dbdb2694a50d07f941">SetMutationBufferFlushInterval</a> (unsigned int millis) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ac9a96017f86bfb6348fca9bfa0b8b5a4">SetMutationBufferMaxNum</a> (unsigned int max_num) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a25b22362650d7120f59cc1025e40bd79">SetTimeoutMillis</a> (int millis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply</a> (<a class="el" href="classkudu_1_1client_1_1KuduWriteOperation.html">KuduWriteOperation</a> *write_op) WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush</a> () WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad8c68570479e95b325d8a5437eef8731">FlushAsync</a> (<a class="el" href="classkudu_1_1client_1_1KuduStatusCallback.html">KuduStatusCallback</a> *cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1Status.html">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aa5204844e361ecc3068fbc4e02fd4436">Close</a> () WARN_UNUSED_RESULT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a3f224e9b95f86da7e1f2ea6fcf327756">HasPendingOperations</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a10edb757e362792454f0974e644109ab">CountBufferedOperations</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a277c213a68679c6b0d5c432919eb9198">CountPendingErrors</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad5e3521623338de49cfd62914bdcb2f7">GetPendingErrors</a> (std::vector&lt; <a class="el" href="classkudu_1_1client_1_1KuduError.html">KuduError</a> * &gt; *errors, bool *overflowed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkudu_1_1client_1_1KuduClient.html">KuduClient</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#a4ed0bac1edcbba612d7de41e8c8adfd5">client</a> () const </td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b5a804db2a148e792148f521f04b486"></a><!-- doxytag: member="kudu::client::KuduSession::KuduClient" ref="a5b5a804db2a148e792148f521f04b486" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>KuduClient</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada57057f15990c8cc54770c782fa9ad4"></a><!-- doxytag: member="kudu::client::KuduSession::internal::Batcher" ref="ada57057f15990c8cc54770c782fa9ad4" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::Batcher</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba2affbf999dd265d3a7f8c30598fec7"></a><!-- doxytag: member="kudu::client::KuduSession::ClientTest" ref="aba2affbf999dd265d3a7f8c30598fec7" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>ClientTest</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Representation of a Kudu client session. </p>
<p>A <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a> belongs to a specific <a class="el" href="classkudu_1_1client_1_1KuduClient.html" title="A handle for a connection to a cluster.">KuduClient</a>, and represents a context in which all read/write data access should take place. Within a session, multiple operations may be accumulated and batched together for better efficiency. Settings like timeouts, priorities, and trace IDs are also set per session.</p>
<p>A KuduSession's main purpose is for grouping together multiple data-access operations together into batches or transactions. It is important to note the distinction between these two:</p>
<ul>
<li>A batch is a set of operations which are grouped together in order to amortize fixed costs such as RPC call overhead and round trip times. A batch DOES NOT imply any ACID-like guarantees. Within a batch, some operations may succeed while others fail, and concurrent readers may see partial results. If the client crashes mid-batch, it is possible that some of the operations will be made durable while others were lost. </li>
<li>In contrast, a transaction is a set of operations which are treated as an indivisible semantic unit, per the usual definitions of database transactions and isolation levels.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Kudu does not currently support transactions! They are only mentioned in the above documentation to clarify that batches are not transactional and should only be used for efficiency.</dd></dl>
<p><a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a> is separate from <a class="el" href="classkudu_1_1client_1_1KuduTable.html" title="A representation of a table on a particular cluster.">KuduTable</a> because a given batch or transaction may span multiple tables. This is particularly important in the future when we add ACID support, but even in the context of batching, we may be able to coalesce writes to different tables hosted on the same server into the same RPC.</p>
<p><a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a> is separate from <a class="el" href="classkudu_1_1client_1_1KuduClient.html" title="A handle for a connection to a cluster.">KuduClient</a> because, in a multi-threaded application, different threads may need to concurrently execute transactions. Similar to a JDBC "session", transaction boundaries will be delineated on a per-session basis -- in between a "BeginTransaction" and "Commit" call on a given session, all operations will be part of the same transaction. Meanwhile another concurrent Session object can safely run non-transactional work or other transactions without interfering.</p>
<p>Additionally, there is a guarantee that writes from different sessions do not get batched together into the same RPCs -- this means that latency-sensitive clients can run through the same <a class="el" href="classkudu_1_1client_1_1KuduClient.html" title="A handle for a connection to a cluster.">KuduClient</a> object as throughput-oriented clients, perhaps by setting the latency-sensitive session's timeouts low and priorities high. Without the separation of batches, a latency-sensitive single-row insert might get batched along with 10MB worth of inserts from the batch writer, thus delaying the response significantly.</p>
<p>Though we currently do not have transactional support, users will be forced to use a <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a> to instantiate reads as well as writes. This will make it more straight-forward to add RW transactions in the future without significant modifications to the API.</p>
<p>Users who are familiar with the Hibernate ORM framework should find this concept of a Session familiar.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This class is not thread-safe. </dd></dl>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="aabd55109ba3b086bbe33b277cdd40d22"></a><!-- doxytag: member="kudu::client::KuduSession::ExternalConsistencyMode" ref="aabd55109ba3b086bbe33b277cdd40d22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22">kudu::client::KuduSession::ExternalConsistencyMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The possible external consistency modes on which Kudu operates. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aabd55109ba3b086bbe33b277cdd40d22ae978fab7451faebf4399830b603c855c"></a><!-- doxytag: member="CLIENT_PROPAGATED" ref="aabd55109ba3b086bbe33b277cdd40d22ae978fab7451faebf4399830b603c855c" args="" -->CLIENT_PROPAGATED</em>&nbsp;</td><td>
<p>The response to any write will contain a timestamp. Any further calls from the same client to other servers will update those servers with that timestamp. Following write operations from the same client will be assigned timestamps that are strictly higher, enforcing external consistency without having to wait or incur any latency penalties.</p>
<p>In order to maintain external consistency for writes between two different clients in this mode, the user must forward the timestamp from the first client to the second by using <a class="el" href="classkudu_1_1client_1_1KuduClient.html#a3a671b3540c74ef7c358bb98e95031e0">KuduClient::GetLatestObservedTimestamp()</a> and <a class="el" href="classkudu_1_1client_1_1KuduClient.html#a0809b055eda76fd68988462f2a9791dd">KuduClient::SetLatestObservedTimestamp()</a>.</p>
<p>This is the default external consistency mode.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Failure to propagate timestamp information through back-channels between two different clients will negate any external consistency guarantee under this mode. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aabd55109ba3b086bbe33b277cdd40d22a70010f3ef1f70b99b02328c024c436c9"></a><!-- doxytag: member="COMMIT_WAIT" ref="aabd55109ba3b086bbe33b277cdd40d22a70010f3ef1f70b99b02328c024c436c9" args="" -->COMMIT_WAIT</em>&nbsp;</td><td>
<p>The server will guarantee that write operations from the same or from other client are externally consistent, without the need to propagate timestamps across clients. This is done by making write operations wait until there is certainty that all follow up write operations (operations that start after the previous one finishes) will be assigned a timestamp that is strictly higher, enforcing external consistency.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Depending on the clock synchronization state of TabletServers this may imply considerable latency. Moreover operations in <code>COMMIT_WAIT</code> external consistency mode will outright fail if TabletServer clocks are either unsynchronized or synchronized but with a maximum error which surpasses a pre-configured threshold. </dd></dl>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aaec3956e642610d703f3b83b78e24e19"></a><!-- doxytag: member="kudu::client::KuduSession::FlushMode" ref="aaec3956e642610d703f3b83b78e24e19" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19">kudu::client::KuduSession::FlushMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modes of flush operations. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aaec3956e642610d703f3b83b78e24e19ad74b76e407e62ca951d369521636df2b"></a><!-- doxytag: member="AUTO_FLUSH_SYNC" ref="aaec3956e642610d703f3b83b78e24e19ad74b76e407e62ca951d369521636df2b" args="" -->AUTO_FLUSH_SYNC</em>&nbsp;</td><td>
<p>Every write will be sent to the server in-band with the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> call. No batching will occur. In this mode, the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush()</a> call never has any effect, since each <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> call has already flushed the buffer. This is the default flush mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aaec3956e642610d703f3b83b78e24e19a520b8eef7ef0fd149b2757faf43972b1"></a><!-- doxytag: member="AUTO_FLUSH_BACKGROUND" ref="aaec3956e642610d703f3b83b78e24e19a520b8eef7ef0fd149b2757faf43972b1" args="" -->AUTO_FLUSH_BACKGROUND</em>&nbsp;</td><td>
<p><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> calls will return immediately (unless there is not enough buffer space to accommodate the newly added operations), but the writes will be sent in the background, potentially batched together with other writes from the same session. If there is not sufficient buffer space, <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> blocks for buffer space to become available.</p>
<p>Because writes are applied in the background, any errors will be stored in a session-local buffer. Call <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a277c213a68679c6b0d5c432919eb9198">CountPendingErrors()</a> or <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad5e3521623338de49cfd62914bdcb2f7">GetPendingErrors()</a> to retrieve them.</p>
<p>In this mode, calling the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad8c68570479e95b325d8a5437eef8731">FlushAsync()</a> or <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush()</a> methods causes a flush that normally would have happened at some point in the near future to happen right now. The <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush()</a> call can be used to block until the current batch is sent and the reclaimed space is available for new operations.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Provide an API for the user to specify a callback to do their own error reporting. </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aaec3956e642610d703f3b83b78e24e19a1db3efc2094da09aae45bb68475cdb4a"></a><!-- doxytag: member="MANUAL_FLUSH" ref="aaec3956e642610d703f3b83b78e24e19a1db3efc2094da09aae45bb68475cdb4a" args="" -->MANUAL_FLUSH</em>&nbsp;</td><td>
<p><a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> calls will return immediately, and the writes will not be sent until the user calls <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush()</a>. If the buffer runs past the configured space limit, then <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> will return an error. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad3f7324b27fca298c5ca3d07b4741943"></a><!-- doxytag: member="kudu::client::KuduSession::Apply" ref="ad3f7324b27fca298c5ca3d07b4741943" args="(KuduWriteOperation *write_op) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::Apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduWriteOperation.html">KuduWriteOperation</a> *&nbsp;</td>
          <td class="paramname"> <em>write_op</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Add "doAs" ability here for proxy servers to be able to act on behalf of other users, assuming access rights. </dd></dl>
<p>Apply the write operation.</p>
<p>The behavior of this function depends on the current flush mode. Regardless of flush mode, however, <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> may begin to perform processing in the background for the call (e.g. looking up the tablet, etc). Given that, an error may be queued into the PendingErrors structure prior to flushing, even in <code>MANUAL_FLUSH</code> mode.</p>
<p>In case of any error, which may occur during flushing or because the write_op is malformed, the write_op is stored in the session's error collector which may be retrieved at any time.</p>
<p>A <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a> accumulates write operations submitted via the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> method in mutation buffers. A <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a> always has at least one mutation buffer. In any flush mode, this call may block if the maximum number of mutation buffers per session is reached (use <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ac9a96017f86bfb6348fca9bfa0b8b5a4">KuduSession::SetMutationBufferMaxNum()</a> to set the limit on maximum number of batchers).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>write_op</em>&nbsp;</td><td>Operation to apply. This method transfers the write_op's ownership to the <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ed0bac1edcbba612d7de41e8c8adfd5"></a><!-- doxytag: member="kudu::client::KuduSession::client" ref="a4ed0bac1edcbba612d7de41e8c8adfd5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1client_1_1KuduClient.html">KuduClient</a>* kudu::client::KuduSession::client </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Client for the session: pointer to the associated client object. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5204844e361ecc3068fbc4e02fd4436"></a><!-- doxytag: member="kudu::client::KuduSession::Close" ref="aa5204844e361ecc3068fbc4e02fd4436" args="() WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::Close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classkudu_1_1Status.html" title="A representation of an operation&#39;s outcome.">Status</a> of the session closure. In particular, an error is returned if there are unflushed or in-flight operations. </dd></dl>

</div>
</div>
<a class="anchor" id="a10edb757e362792454f0974e644109ab"></a><!-- doxytag: member="kudu::client::KuduSession::CountBufferedOperations" ref="a10edb757e362792454f0974e644109ab" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kudu::client::KuduSession::CountBufferedOperations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get number of buffered operations (not the same as 'pending').</p>
<p>Note that this is different than <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a3f224e9b95f86da7e1f2ea6fcf327756">HasPendingOperations()</a> above, which includes operations which have been sent and not yet responded to. This is only relevant in <code>MANUAL_FLUSH</code> mode, where the result will not decrease except for after a manual flush, after which point it will be 0. In the other flush modes, data is immediately put en-route to the destination, so this will return 0.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of buffered operations. These are operations that have not yet been flushed -- i.e. they are not en-route yet. </dd></dl>

</div>
</div>
<a class="anchor" id="a277c213a68679c6b0d5c432919eb9198"></a><!-- doxytag: member="kudu::client::KuduSession::CountPendingErrors" ref="a277c213a68679c6b0d5c432919eb9198" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kudu::client::KuduSession::CountPendingErrors </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get error count for pending operations.</p>
<p>Errors may accumulate in session's lifetime; use this method to see how many errors happened since last call of <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad5e3521623338de49cfd62914bdcb2f7">GetPendingErrors()</a> method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Total count of errors accumulated during the session. </dd></dl>

</div>
</div>
<a class="anchor" id="a64955abb5f5cc821b6e56354f733ce84"></a><!-- doxytag: member="kudu::client::KuduSession::Flush" ref="a64955abb5f5cc821b6e56354f733ce84" args="() WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::Flush </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flush any pending writes.</p>
<p>This method initiates flushing of the current batch of buffered write operations, if any, and then awaits for completion of all pending operations of the session. I.e., after successful return from this method no pending operations should be left in the session.</p>
<p>In <code>AUTO_FLUSH_SYNC</code> mode, calling this method has no effect, since every <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> call flushes itself inline.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. In particular, returns a non-OK status if there are any pending errors after the rows have been flushed. Callers should then use GetPendingErrors to determine which specific operations failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8c68570479e95b325d8a5437eef8731"></a><!-- doxytag: member="kudu::client::KuduSession::FlushAsync" ref="ad8c68570479e95b325d8a5437eef8731" args="(KuduStatusCallback *cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kudu::client::KuduSession::FlushAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduStatusCallback.html">KuduStatusCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>cb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flush any pending writes asynchronously.</p>
<p>This method schedules a background flush of the latest batch of buffered write operations. Provided callback is invoked upon the flush completion of the latest batch of buffered write operations. If there were errors while flushing the operations, corresponding 'not OK' status is passed as a parameter for the callback invocation. Callers should then use <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad5e3521623338de49cfd62914bdcb2f7">GetPendingErrors()</a> to determine which specific operations failed.</p>
<p>In the case that the async version of this method is used, then the callback will be called upon completion of the operations which were buffered since the last flush. In other words, in the following sequence: </p>
<div class="fragment"><pre class="fragment">   session-&gt;Insert(a);
   session-&gt;FlushAsync(callback_1);
   session-&gt;Insert(b);
   session-&gt;FlushAsync(callback_2);
</pre></div><p> ... <code>callback_2</code> will be triggered once <code>b</code> has been inserted, regardless of whether <code>a</code> has completed or not. That means there might be pending operations left in prior batches even after the the callback has been invoked to report on the flush status of the latest batch.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This also means that, if FlushAsync is called twice in succession, with no intervening operations, the second flush will return immediately. For example: <div class="fragment"><pre class="fragment">   session-&gt;Insert(a);
   session-&gt;FlushAsync(callback_1); <span class="comment">// called when &apos;a&apos; is inserted</span>
   session-&gt;FlushAsync(callback_2); <span class="comment">// called immediately!</span>
</pre></div> Note that, as in all other async functions in Kudu, the callback may be called either from an IO thread or the same thread which calls FlushAsync. The callback should not block.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cb</em>&nbsp;</td><td>Callback to call upon flush completion. The <code>cb</code> must remain valid until it is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5e3521623338de49cfd62914bdcb2f7"></a><!-- doxytag: member="kudu::client::KuduSession::GetPendingErrors" ref="ad5e3521623338de49cfd62914bdcb2f7" args="(std::vector&lt; KuduError * &gt; *errors, bool *overflowed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kudu::client::KuduSession::GetPendingErrors </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classkudu_1_1client_1_1KuduError.html">KuduError</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>overflowed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get information on errors from previous session activity.</p>
<p>The information on errors are reset upon calling this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>errors</em>&nbsp;</td><td>Pointer to the container to fill with error info objects. Caller takes ownership of the returned errors in the container. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>overflowed</em>&nbsp;</td><td>If there were more errors than could be held in the session's error storage, then <code>overflowed</code> is set to <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f224e9b95f86da7e1f2ea6fcf327756"></a><!-- doxytag: member="kudu::client::KuduSession::HasPendingOperations" ref="a3f224e9b95f86da7e1f2ea6fcf327756" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kudu::client::KuduSession::HasPendingOperations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if there are any pending operations in this session.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if there are operations which have not yet been delivered to the cluster. This may include buffered operations (i.e. those that have not yet been flushed) as well as in-flight operations (i.e. those that are in the process of being sent to the servers).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Maybe "incomplete" or "undelivered" is clearer? </dd></dl>

</div>
</div>
<a class="anchor" id="a56d1c7f47dfcaf5121b15a4435a8eeca"></a><!-- doxytag: member="kudu::client::KuduSession::SetExternalConsistencyMode" ref="a56d1c7f47dfcaf5121b15a4435a8eeca" args="(ExternalConsistencyMode m) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetExternalConsistencyMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aabd55109ba3b086bbe33b277cdd40d22">ExternalConsistencyMode</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set external consistency mode for the session.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>External consistency mode to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a83555781b5a037f87c215e565ecf1a8f"></a><!-- doxytag: member="kudu::client::KuduSession::SetFlushMode" ref="a83555781b5a037f87c215e565ecf1a8f" args="(FlushMode m) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetFlushMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkudu_1_1client_1_1KuduSession.html#aaec3956e642610d703f3b83b78e24e19">FlushMode</a>&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the flush mode.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>There should be no pending writes -- call <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">Flush()</a> first to ensure nothing is pending.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>Flush mode to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status. </dd></dl>

</div>
</div>
<a class="anchor" id="aabe75f0688f992dbdb2694a50d07f941"></a><!-- doxytag: member="kudu::client::KuduSession::SetMutationBufferFlushInterval" ref="aabe75f0688f992dbdb2694a50d07f941" args="(unsigned int millis) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetMutationBufferFlushInterval </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>millis</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the interval for time-based flushing of the mutation buffer.</p>
<p>In some cases, while running in AUTO_FLUSH_BACKGROUND mode, the size of the mutation buffer for pending operations and the flush watermark for fresh operations may be too high for the rate of incoming data: it would take too long to accumulate enough data in the buffer to trigger flushing. I.e., it makes sense to flush the accumulated operations if the prior flush happened long time ago. This method sets the wait interval for the time-based flushing which takes place along with the flushing triggered by the over-the-watermark criterion. By default, the interval is set to 1000 ms (i.e. 1 second).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This setting is applicable only for AUTO_FLUSH_BACKGROUND sessions. I.e., calling this method in other flush modes is safe, but the parameter has no effect until the session is switched into AUTO_FLUSH_BACKGROUND mode.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td>The duration of the interval for the time-based flushing, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a7311344cec37b3847217197c35467cdf"></a><!-- doxytag: member="kudu::client::KuduSession::SetMutationBufferFlushWatermark" ref="a7311344cec37b3847217197c35467cdf" args="(double watermark_pct) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetMutationBufferFlushWatermark </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>watermark_pct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the buffer watermark to trigger flush in AUTO_FLUSH_BACKGROUND mode.</p>
<p>This method sets the watermark for fresh operations in the buffer when running in AUTO_FLUSH_BACKGROUND mode: once the specified threshold is reached, the session starts sending the accumulated write operations to the appropriate tablet servers. By default, the buffer flush watermark is to to 80%.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This setting is applicable only for AUTO_FLUSH_BACKGROUND sessions. I.e., calling this method in other flush modes is safe, but the parameter has no effect until the session is switched into AUTO_FLUSH_BACKGROUND mode.</dd>
<dd>
The buffer contains data for fresh (i.e. newly submitted) operations and also operations which are scheduled for flush or being flushed. The flush watermark determines how much of the buffer space is taken by newly submitted operations. Setting this level to 1.0 (i.e. 100%) results in flushing the buffer only when the newly applied operation would overflow the buffer.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>watermark_pct</em>&nbsp;</td><td>Watermark level as percentage of the mutation buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9a96017f86bfb6348fca9bfa0b8b5a4"></a><!-- doxytag: member="kudu::client::KuduSession::SetMutationBufferMaxNum" ref="ac9a96017f86bfb6348fca9bfa0b8b5a4" args="(unsigned int max_num) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetMutationBufferMaxNum </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>max_num</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the maximum number of mutation buffers per <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a> object.</p>
<p>A <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a> accumulates write operations submitted via the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">Apply()</a> method in mutation buffers. A <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a> always has at least one mutation buffer. The mutation buffer which accumulates new incoming operations is called the <em>current mutation buffer</em>. The current mutation buffer is flushed either explicitly using the <a class="el" href="classkudu_1_1client_1_1KuduSession.html#a64955abb5f5cc821b6e56354f733ce84">KuduSession::Flush()</a> and/or <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad8c68570479e95b325d8a5437eef8731">KuduSession::FlushAsync()</a> methods or it's done by the <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a> automatically if running in AUTO_FLUSH_BACKGROUND mode. After flushing the current mutation buffer, a new buffer is created upon calling <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">KuduSession::Apply()</a>, provided the limit is not exceeded. A call to <a class="el" href="classkudu_1_1client_1_1KuduSession.html#ad3f7324b27fca298c5ca3d07b4741943">KuduSession::Apply()</a> blocks if it's at the maximum number of buffers allowed; the call unblocks as soon as one of the pending batchers finished flushing and a new batcher can be created.</p>
<p>The minimum setting for this parameter is 1 (one). The default setting for this parameter is 2 (two).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_num</em>&nbsp;</td><td>The maximum number of mutation buffers per <a class="el" href="classkudu_1_1client_1_1KuduSession.html" title="Representation of a Kudu client session.">KuduSession</a> object to hold the applied operations. Use <code>0</code> to set the maximum number of concurrent mutation buffers to unlimited. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="aefa9bbc51c27104ce103b9ecda3b8abf"></a><!-- doxytag: member="kudu::client::KuduSession::SetMutationBufferSpace" ref="aefa9bbc51c27104ce103b9ecda3b8abf" args="(size_t size_bytes) WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkudu_1_1Status.html">Status</a> kudu::client::KuduSession::SetMutationBufferSpace </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size_bytes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the amount of buffer space used by this session for outbound writes.</p>
<p>The effect of the buffer size varies based on the flush mode of the session: </p>
<ul>
<li>AUTO_FLUSH_SYNC since no buffering is done, this has no effect. </li>
<li>AUTO_FLUSH_BACKGROUND if the buffer space is exhausted, then write calls will block until there is space available in the buffer. </li>
<li>MANUAL_FLUSH if the buffer space is exhausted, then write calls will return an error</li>
</ul>
<p>By default, the buffer space is set to 7 MiB (i.e. 7 * 1024 * 1024 bytes).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size_bytes</em>&nbsp;</td><td>Size of the buffer space to set (number of bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation result status. </dd></dl>

</div>
</div>
<a class="anchor" id="a25b22362650d7120f59cc1025e40bd79"></a><!-- doxytag: member="kudu::client::KuduSession::SetTimeoutMillis" ref="a25b22362650d7120f59cc1025e40bd79" args="(int millis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kudu::client::KuduSession::SetTimeoutMillis </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>millis</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the timeout for writes made in this session.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>millis</em>&nbsp;</td><td>Timeout to set in milliseconds; should be greater or equal to 0. If the parameter value is less than 0, it's implicitly set to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/kudu/client/<a class="el" href="client_8h_source.html">client.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!-- start footer part -->
<hr class="footer"/>
<address class="footer">
  <small>Generated for Kudu version 1.0.1 on Tue Oct 11 08:52:01 2016 by Doxygen 1.6.1</small>
  <br>
  <small>Copyright © 2016 The Apache Software Foundation.</small>
</address>
</body>
</html>
